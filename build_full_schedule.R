# Load libraries
library(lubridate)
library(stringr)
library(tidyr)
library(dplyr)
library(rvest)

# Source functions
source("functions/CatchupPause.R")
source("functions/extract_schedule.R")

# Loop through each processed session link and extract the schedule, where appropriate
# Counter / timer to measure progress
# Each loop adds a potential data frame generated by extract_schedule() to a list
new_df <- list(NULL)
counter <- 0
starttime <- Sys.time()
for(i in mylinks)
{
  counter <- counter + 1
  print(paste(counter, "of", length(mylinks)))
  if(counter %% 25 == 0) {
    print(paste("elapsed time =", round(as.numeric(difftime(Sys.time(), starttime, unit="sec"))), "seconds"))
    CatchupPause(1)
  }
  new_df[[length(new_df) + 1]] <- extract_schedule(i)
}

# Bind the data frames in the list together
talks <- bind_rows(new_df)

# Tidy the results and export as a .csv
talks <- talks %>%
  tidyr::separate(time, into = c("hour", "min"), sep = ":") %>%
  tidyr::separate(min, into = c("min", "am_pm"), sep = 2) %>%
  mutate(hour = as.numeric(hour),
         min = as.numeric(min),
         hour = ifelse(am_pm == "PM", hour + 12, hour),
         date = mdy(talks$date),
         datetime = ymd_hm(paste(date, hour, min, sep="-"))) %>%
  select(date, datetime, location, room, session, title, link) %>%
  write.csv("afs_talks.csv", row.names = FALSE)
